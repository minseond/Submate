import {
  EmblaCarousel
} from "./chunk-L2GABWMY.js";
import {
  Box,
  ChevronIcon,
  UnstyledButton,
  createSafeContext,
  createStyles,
  getBreakpointValue,
  getSize,
  getSortedBreakpoints,
  rem,
  useComponentDefaultProps
} from "./chunk-LS5DX7JT.js";
import "./chunk-46PF4JG3.js";
import {
  clamp
} from "./chunk-65XGIN77.js";
import "./chunk-AIWIYUBO.js";
import "./chunk-X3B7SAOS.js";
import {
  require_react
} from "./chunk-RDZYK52F.js";
import {
  __toESM
} from "./chunk-5WWUZCGV.js";

// node_modules/embla-carousel-react/embla-carousel-react.esm.js
var import_react = __toESM(require_react());
function canUseDOM() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
function sortAndMapPluginToOptions(plugins) {
  return plugins.concat().sort(function(a, b) {
    return a.name > b.name ? 1 : -1;
  }).map(function(plugin) {
    return plugin.options;
  });
}
function arePluginsEqual(pluginsA, pluginsB) {
  if (pluginsA.length !== pluginsB.length)
    return false;
  var areEqual = EmblaCarousel.optionsHandler().areEqual;
  var optionsA = sortAndMapPluginToOptions(pluginsA);
  var optionsB = sortAndMapPluginToOptions(pluginsB);
  return optionsA.every(function(optionA, index) {
    var optionB = optionsB[index];
    return areEqual(optionA, optionB);
  });
}
function useEmblaCarousel(options, plugins) {
  if (options === void 0) {
    options = {};
  }
  if (plugins === void 0) {
    plugins = [];
  }
  var optionsHandler = (0, import_react.useRef)(EmblaCarousel.optionsHandler());
  var storedOptions = (0, import_react.useRef)(options);
  var storedPlugins = (0, import_react.useRef)(plugins);
  var _a = (0, import_react.useState)(), embla = _a[0], setEmbla = _a[1];
  var _b = (0, import_react.useState)(), viewport = _b[0], setViewport = _b[1];
  var reInit = (0, import_react.useCallback)(function() {
    if (embla)
      embla.reInit(storedOptions.current, storedPlugins.current);
  }, [embla]);
  (0, import_react.useEffect)(function() {
    if (canUseDOM() && viewport) {
      EmblaCarousel.globalOptions = useEmblaCarousel.globalOptions;
      var newEmbla_1 = EmblaCarousel(viewport, storedOptions.current, storedPlugins.current);
      setEmbla(newEmbla_1);
      return function() {
        return newEmbla_1.destroy();
      };
    } else {
      setEmbla(void 0);
    }
  }, [viewport, setEmbla]);
  (0, import_react.useEffect)(function() {
    if (optionsHandler.current.areEqual(storedOptions.current, options))
      return;
    storedOptions.current = options;
    reInit();
  }, [options, reInit]);
  (0, import_react.useEffect)(function() {
    if (arePluginsEqual(storedPlugins.current, plugins))
      return;
    storedPlugins.current = plugins;
    reInit();
  }, [plugins, reInit]);
  return [setViewport, embla];
}
useEmblaCarousel.globalOptions = void 0;

// node_modules/@mantine/carousel/esm/Carousel.js
var import_react3 = __toESM(require_react());

// node_modules/@mantine/carousel/esm/Carousel.errors.js
var CAROUSEL_ERRORS = {
  context: "[@mantine/carousel] Carousel.Slide was rendered outside of Carousel context"
};

// node_modules/@mantine/carousel/esm/Carousel.context.js
var [CarouselProvider, useCarouselContext] = createSafeContext(CAROUSEL_ERRORS.context);

// node_modules/@mantine/carousel/esm/Carousel.styles.js
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var useStyles = createStyles((theme, {
  controlSize,
  controlsOffset,
  orientation,
  height,
  includeGapInSize,
  breakpoints = [],
  slideGap
}) => {
  const horizontal = orientation === "horizontal";
  const getContainerStyles = (gap) => {
    if (!includeGapInSize)
      return {};
    const slideGapValue = getSize({ size: gap, sizes: theme.spacing });
    return {
      [orientation === "horizontal" ? "marginRight" : "marginBottom"]: `calc(${slideGapValue} * -1)`
    };
  };
  const hasDiff = breakpoints.some((v) => typeof v.slideGap !== "undefined" || typeof v.slideSize !== "undefined");
  const containerBreakpoints = !hasDiff ? null : getSortedBreakpoints(theme, breakpoints).reduce((acc, breakpoint) => {
    const property = "maxWidth" in breakpoint ? "max-width" : "min-width";
    const breakpointSize = getSize({
      size: property === "max-width" ? breakpoint.maxWidth : breakpoint.minWidth,
      sizes: theme.breakpoints
    });
    const breakpointSlideGap = typeof breakpoint.slideGap === "undefined" ? void 0 : rem(breakpoint.slideGap);
    const breakpointValue = getBreakpointValue(breakpointSize) - (property === "max-width" ? 1 : 0);
    acc[`@media (${property}: ${rem(breakpointValue)})`] = getContainerStyles(breakpointSlideGap);
    return acc;
  }, {});
  return {
    root: {
      position: "relative"
    },
    viewport: {
      height: rem(height),
      overflow: "hidden"
    },
    container: __spreadValues(__spreadValues({
      display: "flex",
      flexDirection: horizontal ? "row" : "column",
      height: rem(height)
    }, getContainerStyles(slideGap)), containerBreakpoints),
    controls: {
      position: "absolute",
      zIndex: 1,
      left: horizontal ? 0 : `calc(50% - ${rem(controlSize)} / 2)`,
      right: horizontal ? 0 : void 0,
      top: horizontal ? `calc(50% - ${rem(controlSize)} / 2)` : 0,
      bottom: horizontal ? void 0 : 0,
      display: "flex",
      flexDirection: horizontal ? "row" : "column",
      alignItems: "center",
      justifyContent: "space-between",
      paddingLeft: horizontal ? getSize({ size: controlsOffset, sizes: theme.spacing }) : void 0,
      paddingRight: horizontal ? getSize({ size: controlsOffset, sizes: theme.spacing }) : void 0,
      paddingTop: !horizontal ? getSize({ size: controlsOffset, sizes: theme.spacing }) : void 0,
      paddingBottom: !horizontal ? getSize({ size: controlsOffset, sizes: theme.spacing }) : void 0,
      pointerEvents: "none"
    },
    control: __spreadProps(__spreadValues({
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      minWidth: rem(controlSize),
      minHeight: rem(controlSize),
      borderRadius: rem(controlSize),
      pointerEvents: "all",
      backgroundColor: theme.white,
      color: theme.black,
      boxShadow: theme.shadows.md,
      opacity: theme.colorScheme === "dark" ? 0.65 : 0.85,
      border: `${rem(1)} solid ${theme.colors.gray[3]}`,
      transition: `opacity 150ms ${theme.transitionTimingFunction}`
    }, theme.fn.hover({ opacity: 1 })), {
      "&:active": theme.activeStyles
    }),
    indicators: {
      position: "absolute",
      bottom: horizontal ? theme.spacing.md : 0,
      top: horizontal ? void 0 : 0,
      left: horizontal ? 0 : void 0,
      right: horizontal ? 0 : theme.spacing.md,
      display: "flex",
      flexDirection: horizontal ? "row" : "column",
      justifyContent: "center",
      gap: rem(8),
      pointerEvents: "none"
    },
    indicator: {
      pointerEvents: "all",
      width: horizontal ? rem(25) : rem(5),
      height: horizontal ? rem(5) : rem(25),
      borderRadius: theme.radius.xl,
      backgroundColor: theme.white,
      boxShadow: theme.shadows.sm,
      opacity: 0.6,
      transition: `opacity 150ms ${theme.transitionTimingFunction}`,
      "&[data-active]": {
        opacity: 1
      }
    }
  };
});
var Carousel_styles_default = useStyles;

// node_modules/@mantine/carousel/esm/CarouselSlide/CarouselSlide.js
var import_react2 = __toESM(require_react());

// node_modules/@mantine/carousel/esm/CarouselSlide/CarouselSlide.styles.js
var __defProp2 = Object.defineProperty;
var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues2 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp2.call(b, prop))
      __defNormalProp2(a, prop, b[prop]);
  if (__getOwnPropSymbols2)
    for (var prop of __getOwnPropSymbols2(b)) {
      if (__propIsEnum2.call(b, prop))
        __defNormalProp2(a, prop, b[prop]);
    }
  return a;
};
var useStyles2 = createStyles((theme, { size, gap, orientation, includeGapInSize, breakpoints = [] }) => {
  const getSlideStyles = (slideGap, slideSize) => {
    const slideGapValue = getSize({
      size: slideGap,
      sizes: theme.spacing
    });
    const flexBasisValue = rem(slideSize);
    const marginStyles = includeGapInSize ? {
      [orientation === "horizontal" ? "paddingRight" : "paddingBottom"]: slideGapValue
    } : {
      [orientation === "horizontal" ? "marginRight" : "marginBottom"]: slideGapValue
    };
    return __spreadValues2({
      flex: `0 0 ${flexBasisValue}`
    }, marginStyles);
  };
  const hasDiff = breakpoints.some((v) => typeof v.slideGap !== "undefined" || typeof v.slideSize !== "undefined");
  const slideBreakpoints = !hasDiff ? null : getSortedBreakpoints(theme, breakpoints).reduce((acc, breakpoint) => {
    const property = "maxWidth" in breakpoint ? "max-width" : "min-width";
    const breakpointSize = getSize({
      size: property === "max-width" ? breakpoint.maxWidth : breakpoint.minWidth,
      sizes: theme.breakpoints
    });
    const breakpointGap = typeof breakpoint.slideGap === "undefined" ? gap : breakpoint.slideGap;
    const breakpointValue = getBreakpointValue(breakpointSize) - (property === "max-width" ? 1 : 0);
    acc[`@media (${property}: ${rem(breakpointValue)})`] = getSlideStyles(breakpointGap, breakpoint.slideSize);
    return acc;
  }, {});
  return {
    slide: __spreadValues2(__spreadValues2({
      position: "relative"
    }, getSlideStyles(gap, size)), slideBreakpoints)
  };
});
var CarouselSlide_styles_default = useStyles2;

// node_modules/@mantine/carousel/esm/CarouselSlide/CarouselSlide.js
var __defProp3 = Object.defineProperty;
var __getOwnPropSymbols3 = Object.getOwnPropertySymbols;
var __hasOwnProp3 = Object.prototype.hasOwnProperty;
var __propIsEnum3 = Object.prototype.propertyIsEnumerable;
var __defNormalProp3 = (obj, key, value) => key in obj ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues3 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp3.call(b, prop))
      __defNormalProp3(a, prop, b[prop]);
  if (__getOwnPropSymbols3)
    for (var prop of __getOwnPropSymbols3(b)) {
      if (__propIsEnum3.call(b, prop))
        __defNormalProp3(a, prop, b[prop]);
    }
  return a;
};
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp3.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols3)
    for (var prop of __getOwnPropSymbols3(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum3.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var CarouselSlide = (0, import_react2.forwardRef)((_a, ref) => {
  var _b = _a, { children, className, size, gap } = _b, others = __objRest(_b, ["children", "className", "size", "gap"]);
  const ctx = useCarouselContext();
  const { classes, cx } = CarouselSlide_styles_default({
    gap: typeof gap === "undefined" ? ctx.slideGap : gap,
    size: typeof size === "undefined" ? ctx.slideSize : size,
    orientation: ctx.orientation,
    includeGapInSize: ctx.includeGapInSize,
    breakpoints: ctx.breakpoints
  }, {
    name: "Carousel",
    classNames: ctx.classNames,
    styles: ctx.styles,
    unstyled: ctx.unstyled,
    variant: ctx.variant
  });
  return import_react2.default.createElement(Box, __spreadValues3({
    className: cx(classes.slide, className),
    ref
  }, others), children);
});
CarouselSlide.displayName = "@mantine/carousel/CarouselSlide";

// node_modules/@mantine/carousel/esm/get-chevron-rotation.js
function getChevronRotation({ dir, orientation, direction }) {
  if (direction === "previous") {
    return orientation === "horizontal" ? 90 * (dir === "ltr" ? 1 : -1) : -180;
  }
  return orientation === "horizontal" ? 90 * (dir === "ltr" ? -1 : 1) : 0;
}

// node_modules/@mantine/carousel/esm/Carousel.js
var __defProp4 = Object.defineProperty;
var __getOwnPropSymbols4 = Object.getOwnPropertySymbols;
var __hasOwnProp4 = Object.prototype.hasOwnProperty;
var __propIsEnum4 = Object.prototype.propertyIsEnumerable;
var __defNormalProp4 = (obj, key, value) => key in obj ? __defProp4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues4 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp4.call(b, prop))
      __defNormalProp4(a, prop, b[prop]);
  if (__getOwnPropSymbols4)
    for (var prop of __getOwnPropSymbols4(b)) {
      if (__propIsEnum4.call(b, prop))
        __defNormalProp4(a, prop, b[prop]);
    }
  return a;
};
var __objRest2 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp4.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols4)
    for (var prop of __getOwnPropSymbols4(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum4.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var defaultProps = {
  controlSize: 26,
  controlsOffset: "sm",
  slideSize: "100%",
  slideGap: 0,
  orientation: "horizontal",
  align: "center",
  slidesToScroll: 1,
  includeGapInSize: true,
  draggable: true,
  dragFree: false,
  loop: false,
  speed: 10,
  initialSlide: 0,
  inViewThreshold: 0,
  withControls: true,
  withIndicators: false,
  skipSnaps: false,
  containScroll: "",
  withKeyboardEvents: true
};
var _Carousel = (0, import_react3.forwardRef)((props, ref) => {
  const _a = useComponentDefaultProps("Carousel", defaultProps, props), {
    children,
    className,
    getEmblaApi,
    onNextSlide,
    onPreviousSlide,
    onSlideChange,
    nextControlLabel,
    previousControlLabel,
    controlSize,
    controlsOffset,
    classNames,
    styles,
    unstyled,
    slideSize,
    slideGap,
    orientation,
    height,
    align,
    slidesToScroll,
    includeGapInSize,
    draggable,
    dragFree,
    loop,
    speed,
    initialSlide,
    inViewThreshold,
    withControls,
    withIndicators,
    plugins,
    nextControlIcon,
    previousControlIcon,
    breakpoints,
    skipSnaps,
    containScroll,
    withKeyboardEvents,
    variant
  } = _a, others = __objRest2(_a, [
    "children",
    "className",
    "getEmblaApi",
    "onNextSlide",
    "onPreviousSlide",
    "onSlideChange",
    "nextControlLabel",
    "previousControlLabel",
    "controlSize",
    "controlsOffset",
    "classNames",
    "styles",
    "unstyled",
    "slideSize",
    "slideGap",
    "orientation",
    "height",
    "align",
    "slidesToScroll",
    "includeGapInSize",
    "draggable",
    "dragFree",
    "loop",
    "speed",
    "initialSlide",
    "inViewThreshold",
    "withControls",
    "withIndicators",
    "plugins",
    "nextControlIcon",
    "previousControlIcon",
    "breakpoints",
    "skipSnaps",
    "containScroll",
    "withKeyboardEvents",
    "variant"
  ]);
  const { classes, cx, theme } = Carousel_styles_default({ controlSize, controlsOffset, orientation, height, includeGapInSize, breakpoints, slideGap }, { name: "Carousel", classNames, styles, unstyled, variant });
  const [emblaRefElement, embla] = useEmblaCarousel({
    axis: orientation === "horizontal" ? "x" : "y",
    direction: orientation === "horizontal" ? theme.dir : void 0,
    startIndex: initialSlide,
    loop,
    align,
    slidesToScroll,
    draggable,
    dragFree,
    speed,
    inViewThreshold,
    skipSnaps,
    containScroll
  }, plugins);
  const [selected, setSelected] = (0, import_react3.useState)(0);
  const [slidesCount, setSlidesCount] = (0, import_react3.useState)(0);
  const handleScroll = (0, import_react3.useCallback)((index) => embla && embla.scrollTo(index), [embla]);
  const handleSelect = (0, import_react3.useCallback)(() => {
    if (!embla)
      return;
    const slide = embla.selectedScrollSnap();
    setSelected(slide);
    onSlideChange == null ? void 0 : onSlideChange(slide);
  }, [embla, setSelected]);
  const handlePrevious = (0, import_react3.useCallback)(() => {
    embla == null ? void 0 : embla.scrollPrev();
    onPreviousSlide == null ? void 0 : onPreviousSlide();
  }, [embla]);
  const handleNext = (0, import_react3.useCallback)(() => {
    embla == null ? void 0 : embla.scrollNext();
    onNextSlide == null ? void 0 : onNextSlide();
  }, [embla]);
  const handleKeydown = (0, import_react3.useCallback)((event) => {
    if (withKeyboardEvents) {
      if (event.key === "ArrowRight") {
        event.preventDefault();
        handleNext();
      }
      if (event.key === "ArrowLeft") {
        event.preventDefault();
        handlePrevious();
      }
    }
  }, [embla]);
  (0, import_react3.useEffect)(() => {
    if (embla) {
      getEmblaApi == null ? void 0 : getEmblaApi(embla);
      handleSelect();
      setSlidesCount(embla.scrollSnapList().length);
      embla.on("select", handleSelect);
      return () => {
        embla.off("select", handleSelect);
      };
    }
    return void 0;
  }, [embla, slidesToScroll]);
  (0, import_react3.useEffect)(() => {
    if (embla) {
      embla.reInit();
      setSlidesCount(embla.scrollSnapList().length);
      setSelected((currentSelected) => clamp(currentSelected, 0, import_react3.Children.toArray(children).length - 1));
    }
  }, [import_react3.Children.toArray(children).length, slidesToScroll]);
  const canScrollPrev = (embla == null ? void 0 : embla.canScrollPrev()) || false;
  const canScrollNext = (embla == null ? void 0 : embla.canScrollNext()) || false;
  const indicators = Array(slidesCount).fill(0).map((_, index) => import_react3.default.createElement(UnstyledButton, {
    key: index,
    "data-active": index === selected || void 0,
    className: classes.indicator,
    "aria-hidden": true,
    tabIndex: -1,
    onClick: () => handleScroll(index)
  }));
  return import_react3.default.createElement(CarouselProvider, {
    value: {
      slideGap,
      slideSize,
      embla,
      orientation,
      includeGapInSize,
      breakpoints,
      classNames,
      styles,
      unstyled,
      variant
    }
  }, import_react3.default.createElement(Box, __spreadValues4({
    className: cx(classes.root, className),
    ref,
    onKeyDownCapture: handleKeydown
  }, others), import_react3.default.createElement("div", {
    className: classes.viewport,
    ref: emblaRefElement
  }, import_react3.default.createElement("div", {
    className: classes.container
  }, children)), withIndicators && import_react3.default.createElement("div", {
    className: classes.indicators
  }, indicators), withControls && import_react3.default.createElement("div", {
    className: classes.controls
  }, import_react3.default.createElement(UnstyledButton, {
    onClick: handlePrevious,
    className: classes.control,
    "aria-label": previousControlLabel,
    "data-inactive": !canScrollPrev || void 0,
    tabIndex: canScrollPrev ? 0 : -1
  }, typeof previousControlIcon !== "undefined" ? previousControlIcon : import_react3.default.createElement(ChevronIcon, {
    style: {
      transform: `rotate(${getChevronRotation({
        dir: theme.dir,
        orientation,
        direction: "previous"
      })}deg)`
    }
  })), import_react3.default.createElement(UnstyledButton, {
    onClick: handleNext,
    className: classes.control,
    "aria-label": nextControlLabel,
    "data-inactive": !canScrollNext || void 0,
    tabIndex: canScrollNext ? 0 : -1
  }, typeof nextControlIcon !== "undefined" ? nextControlIcon : import_react3.default.createElement(ChevronIcon, {
    style: {
      transform: `rotate(${getChevronRotation({
        dir: theme.dir,
        orientation,
        direction: "next"
      })}deg)`
    }
  })))));
});
_Carousel.Slide = CarouselSlide;
_Carousel.displayName = "@mantine/carousel/Carousel";
var Carousel = _Carousel;

// node_modules/@mantine/carousel/esm/use-animation-offset-effect.js
var import_react4 = __toESM(require_react());
function useAnimationOffsetEffect(embla, transitionDuration) {
  (0, import_react4.useEffect)(() => {
    if (embla) {
      window.setTimeout(() => {
        embla.reInit();
      }, transitionDuration);
    }
  }, [embla, transitionDuration]);
}
export {
  Carousel,
  useAnimationOffsetEffect
};
//# sourceMappingURL=@mantine_carousel.js.map
